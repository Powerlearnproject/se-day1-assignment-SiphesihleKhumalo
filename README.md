[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18404178&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

1. Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is defined as a process of designing, developing, testing and maintaining softwares. It forms a big part of computer science and is used by software developers to solve real world problems.

Ensuring reliability
Softwares need to reliable at all times to avoid financial losses and ensures that they permorm accordingly.

Scalability
As the business continues to grow saoftwares used must be able to handle more load or people using for smooth operation.

Innovation
As technology continues to grow, software ngineeres must always build new applications to make everyday activities easy with cool and exciting new features.

Improving efficiency
If the softwares are of high quality it will improve production therefore reducing cost and speeding production.

2. Identify and describe at least three key milestones in the evolution of software engineering.
Mastering the machine
-At this time the name  software engineering was unkown, softwares were used to make hardwares be more effectiv. Operating ststems were not effective and Computer Aided Software Engineering Tools were for editing, compiling and debugging.

Mastering the process (1968-1982)
-This was when doftware engineering first became effective, the main goal was to reduce risks in the development stage for improved quality and productivity. Structured methods included Software Requirement Engineering Methodology(SREM) and the Structured Analysis and Design Tehnique(SADT) came alive and were used for the development of specification documents.

Mastering the communications (1993-2001)
-When the internet was making an impact by reaching new audiences. It was not just on the computers for the sake of being there, it was a highly decentralized environment. It was not just softwares that were bilt but constructing complex interconnected sytems operating with many networks. Software was treated likw an industrial process.

3. List and briefly explain the phases of the Software Development Life Cycle.
Planning- The first step that involves defining the project goals, scope and requirements. Developers, clients and stakeholders meet to discuss the problem that needs to be solved and the reason why it needs to be solved.
Design- This is where the project comes alive, data models, user interface and algorithms are constructed. This phase focuses mainly on bilding the software.
Implemetation- This phase involves coding, this is where programming takes place.
Testing- Tests are done to see if the software is functional and if it meets quality standards.
Deployment- After all tests are done end users or customers get to use the software.
Maintainace- This step is for fixing bugs, adding new features if there are any and giving updates. It is also where issues are addressed. 

4. Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Agile is an iterative approach to software development, emphasizing flexibility and collaboration among cross-functional teams. It focuses on delivering small, incremental releases, adapting to changes throughout the development process.

Waterfall is a linear and sequential approach, where each phase must be completed before moving to the next. Changes are difficult to incorporate once a phase is completed. Agile promotes adaptability and customer feedback, while Waterfall provides a structured plan but may struggle with accommodating changes late in the development cycle.

5. Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

Software Developer - developing applications,programs and systems using programming languages and frameworks.
 - maintaining and updating software to keep it functional. 
- collaborating with other team members to ensure best practice when developing software.
 - reporting to the project manager about the progress of the software development.
Quality Assurance Engineer - collaborate with stakeholders to understand and clarify software requirement.
 - create development standards and procedures for the programmers to follow
 - confirm that the software meets the requirement before deployment. 
- analyse the product to identify bugs and suggest changes to make them more efficient. 
- develop and execute automation scripts using open source tools.
Project Manager - assembles and lead the software development team.
 - discuss the project and it's requirement with the client and software developers.
 - create blueprint for the project.
 - tracking and communicating information regarding the project milestone.
 - deliver the complete software to the client and regularly check its performance.



6. Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Importance of Tools: Software engineering tools enhance productivity, collaboration, and code quality by providing developers with features such as code editors, version control, debugging tools, and automated testing capabilities.

 Integrated Development Environments (IDEs): Software suites that provide comprehensive tools for writing, debugging, and testing code (e.g., Visual Studio, Eclipse, IntelliJ IDEA).

 Version Control Systems (VCS): Software tools for tracking changes to source code and coordinating work among team members (e.g., Git, Subversion).


7. What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

 .Changing Requirements: Requirements may change during the development cycle, leading to scope creep and project delays.
  - Tight Deadlines: Pressure to deliver software products on schedule can result in rushed development and compromised quality.
  - Technical Debt: Accrued from shortcuts or suboptimal solutions, technical debt can impede future development efforts and increase maintenance costs.
Strategies for Overcoming Challenges: Strategies for overcoming challenges include effective communication, agile methodologies, prioritization of tasks, and regular reassessment of project goals and timelines.


8. Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing – Testing One Small Piece at a Time
Think of a car. Before putting the whole car together, you test each part separately—like checking if the engine works before installing it.

What it does: Tests small parts of the code (functions, methods, or modules) one by one.
Why it matters: Catches mistakes early, making them easier to fix.

Example: If an app has a function to calculate a bill, unit testing checks if the function gives the correct total.

2. Integration Testing – Checking if Parts Work Together
Now, imagine all the car parts (engine, wheels, brakes) are working separately. But do they work together? Integration testing checks if connected parts communicate properly.

What it does: Tests how different pieces of the app work together.
Why it matters: Prevents errors when systems or features interact.

Example: A shopping app might work fine when searching for products, but integration testing checks if adding a product to the cart actually updates the total price.

3. System Testing – Testing the Whole Car
After assembling the entire car, you take it for a test drive to check if everything works as expected. That’s system testing.

What it does: Tests the whole app to make sure everything works together.
Why it matters: Finds problems before the app is released.

Example: In a food delivery app, system testing ensures that users can browse restaurants, place an order, and receive a confirmation—all without issues.

4. Acceptance Testing – Getting Final Approval from Users
Even after a car is tested, the buyer takes it for a spin to make sure they like how it drives. Acceptance testing does the same for software—real users test it before launch.

What it does: Checks if the app meets user expectations.
Why it matters: Ensures the final product is useful and user-friendly.

Example: A business might test a new banking app by letting employees try it and give feedback before releasing it to customers.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering the process of writing instructions to get the best results from artificial intelligence (AI) models. It's a combination of human creativity and AI's computational power. 

Enhanced Accuracy:
Well-structured prompts guide the AI model to produce more precise and relevant outputs, reducing the need for manual editing and improving the reliability of AI-generated content. 

User Experience Improvement:
By providing clear instructions through prompts, users can get the information they need with minimal trial and error, leading to a more seamless interaction with AI systems. 

Mitigating Bias:
Careful prompt design can help identify and address potential biases present in the training data, promoting fairness and ethical AI practices. 

Flexibility and Scalability:
Prompt engineering makes it easy to create adaptable prompts that can be used multiple times, allowing for more application of AI models withim an organization.

Control over Output Format:
By specifying desired output formats (e.g., summaries, code snippets, creative writing), prompts allow developers to tailor the AI response to specific needs. 

Preventing Hallucinations:
Proper prompt design can minimize the risk of AI systems generating inaccurate or nonsensical outputs, particularly in sensitive contexts. 

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt:
"Design a website for my business."

Improved Prompt:
"Design a modern, mobile-responsive e-commerce website for my haircare business. The site should have a homepage, product pages, a shopping cart, and a checkout process with PayPal and credit card payment options. Use a soft pastel color scheme, and ensure the design is user-friendly and accessible."

Why the Improved Prompt is More Effective:
Clarifies the Purpose – Specifies that the website is for an e-commerce haircare business.
Defines Key Features – Lists essential components like product pages, a shopping cart, and payment options.
Provides Design Preferences – Mentions the desired aesthetic (soft pastel colors).

